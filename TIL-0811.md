# 2022/08/11

## 새롭게 안 내용

자바스크립트는 외부 상태를 쳐다보지도 않는다.

함수형 프로그래밍은 순수함수만 써야하는 것이 아니다. 부수효과가 있는 것과 없는 것으로 나누는 것이 좋다.

물론 수학 같은 것은 순수로 만들어야겠지만

비순수는 테스트가 어렵다.

순수함수를 지향하돼, 부수효과를 없앨 수는 없다

> 함수형 코딩 이라는 책이 좋다
> 

부수효과를 없애기 위해 너무 치중하지말고, 나누는 코딩을 해야한다.

뒤에보면 일급 객체라는 개념, 함수형 프로그래밍이 가능하냐 아니냐

콜백함수가 함수형의 기본이기 때문이다.  값이기 때문에 변수에 담을 수 있었던 것이다. 함수 리터럴이 평가되면 함수 객체가 만들어지고 함수객체의 참조값이 변수에 전달된다.

객체지향은 주로 상속에 의지한다면,

조합해서 사용하는 방식이 함수형이다.

우리가 만드는 함수는 결국 이벤트 핸들러 내에서 사용되는 경우가 많다.

나중에 MVC도 이해하여야합니다.

지금은 콜백함수에 집중하자.

콜백 함수는 addEventListener 가 나중에 콜 한다는 느낌이고, 

이벤트 핸들러는 브라우저에 의해서 호출된다.

setTimeout은 콜백함수로 써놓긴했지만, 부르는 이름이 다 다르다. 

보조함수라는 이름을 더 좋아한다. 콜백함수라는 이름은 막연하다.

유지보수성이 있으려면?

100줄이 넘어가면 이해하기 어려워질 수 있다는 이야기

양수냐 음수냐 0이냐

공통

파일이 쪼개져 있다구요~~~

모듈이 없어서야~

식별자는 값을 가지고 있는거냐, 주소를 가지고 있는거냐?

식별자는 메모리주소를 기억하고 있다,

선두 address를 알아야함. undefined는 몇바이트일까? 모른다.

ECMAscript 사양서에 undefined의 값은 몇바이트로 어떻게 구현해라는 내용이 없다.

일반적으로 메모리 셀은 1byte일까?

왜 1byte는 8bit 일까?

화두를 던집니다용 ASCII 코드는 몇바이트일까?

메모리가 이렇게 생겼다. 메모리셀에서 정확히 딱 가져와야하는데, 메모리 주소를 어떻게 식별자가 알게되었죠? 이것도 메모리에 저장되어있다.

식별자는 메모리 주소를 가리키는 symbolic 한 이름이다.

값은 값이여. 값은 자기의 주소를 알 필요없다.

식별자가 덩그러니 존재하는게 아니라 사실은 프로퍼티래…

값은 

primitive value는 변하지 않는다.

정수를 표현하는 방식과 실수를 표현하는 방식이 다르다.

undefined 는 어디에 저장이 될까? 몰라용 os의 소관입니다. 

var score 초기화가 된겁니다.

undefined로 암묵적 초기화가 됨

참조값도 값이죠.

값

예전에는 메모리가 귀했기 때문에, 모던한 개발 환경에서는 객체도 원시값처럼 쓰려는 움직임이 있다

제어문

if-else 짝을 쓰는 경우는 거의 없다.

괄호안에 문이 3개다

젤 쉬운 for문은 빠짐없이 도는게 젤 쉬운 for 문임.

map filter reduce 는 처음부터 끝가지 다 돌아

이해하기 편하기 때문

if문이나 for문에서 왜 함수 정의가 왜 추가되었는야 es6

함수는 표현식보다 사용이 어렵기 때문에, 표현식을 사용하는 방식이 좋다. like spread 

기본적으로 제공하는 것은 얕은복사다. 깊은 복사는 메모리 차지가 많으니까

우리에게 알려주지 않는 객체까지 copy 해오기 어렵기 때문에 copy해오는 것이 불가능해 가깝다.

그래서 라이브러리를 사용하는 것이 좋다.

깊은 복사를 남발할 가능성이 있어서 추가하지 않는 것.

gabage collecting 이 되지 않은 상태에서 계속 copy를 하면 메모리가 꽉차는 문제가 있을 수 있기 때문에, 다른 언어들도 깊은 복사를 제공하지 않는다.

깊은 복사를 해야할 경우가 있을 수 있다

식별자는 객체화되어서 저장이 된다.

식별자를 찾으면서 linked list를 찾아본다.

객체가 있을 때 

scope 체인에 들어가 있는 애들이 식별자이고,

프로퍼티는 프로토타입체인에서 찾는 것이다.

그래서 식별자라고 안부른다.

정확히 이야기 할 수 없는게, 객체는 이렇게 만들어라라고 명세되어있지 않다. 왜 구체적으로 명시하지 않을까, 그러면 모든 자바스크립트 엔진이 똑같아질 것. 자율성이 너무 떨어질 것.

객체를 어떻게 만들어라하는 것은 명시되어있지 않다. V8은 히든클래스라는 방식을 쓴다. hashtable을 쓰고, 하지만 꼭 이렇지 않을 수 있다. 말 그대로 클래스를 통해서 객체를 만든다는 것인데, 숨겨져있다는 것.

장점중에 하나가 리터럴로 객체를 만들 수 있다는 것. 다른 언어들은 못한다.

자바에서는 class를 고칠 수 없다.

자바스크립트는 고칠 수 있음. 그래서 객체를 만드는 방법이 훨씬 더 복잡하다.

많이 쓰는 원시값들은 우리 자바스크립트엔진이 동작하는 타임인, 브라우저를 열면, 이러한 상수값들을 심어놓는다

heap, stack은 js와 상관 없어 c에서 하는 이야기야

c에는 원시값들이 들어오고,

객체라는 타입은 3kb라고 정해져있나?

stack은 차곡차곡 쌓는 거고,

heap 은 늘어나고 줄어든다 

c도 그러니까 js도 그렇겠지? 아니야~

heap 이라는 용어는 나오는데, ecma가 아닌 브라우저에서 나오는데 객체들이 들어오는 영역

stack과 heap의 차이는 heap 영역이 더 크고 그곳에 객체를 넣어놓기 때문에, stack 처럼 다닥다닥 붙일 수 없고, 떨어져있어
